var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"CurrentModule = CliqueTrees","category":"page"},{"location":"api/#Lower-Bound-Algorithms","page":"Library Reference","title":"Lower Bound Algorithms","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"LowerBoundAlgorithm\nMMW\nlowerbound\nDEFAULT_LOWER_BOUND_ALGORITHM","category":"page"},{"location":"api/#CliqueTrees.LowerBoundAlgorithm","page":"Library Reference","title":"CliqueTrees.LowerBoundAlgorithm","text":"LowerBoundAlgorithm\n\nAn algorithm for computing a lower bound to the treewidth of a graph. The options are\n\ntype name time space\nMMW minor-min-width  \n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MMW","page":"Library Reference","title":"CliqueTrees.MMW","text":"MMW <: LowerBoundAlgorithm\n\nMMW()\n\nThe minor-min-width heuristic.\n\nReferences\n\nGogate, Vibhav, and Rina Dechter. \"A complete anytime algorithm for treewidth.\" Proceedings of the 20th conference on Uncertainty in artificial intelligence. 2004.\nBodlaender, Hans, Thomas Wolle, and Arie Koster. \"Contraction and treewidth lower bounds.\" Journal of Graph Algorithms and Applications 10.1 (2006): 5-49.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.lowerbound","page":"Library Reference","title":"CliqueTrees.lowerbound","text":"lowerbound([weights, ]graph;\n    alg::LowerBoundAlgorithm=DEFAULT_LOWER_BOUND_ALGORITHM)\n\nCompute a lower bound to the treewidth of a graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.DEFAULT_LOWER_BOUND_ALGORITHM","page":"Library Reference","title":"CliqueTrees.DEFAULT_LOWER_BOUND_ALGORITHM","text":"DEFAULT_LOWER_BOUND_ALGORITHM = MMW()\n\n\n\n\n\n","category":"constant"},{"location":"api/#Elimination-Algorithms","page":"Library Reference","title":"Elimination Algorithms","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"EliminationAlgorithm\nPermutationOrAlgorithm\nDEFAULT_ELIMINATION_ALGORITHM\nBFS\nMCS\nLexBFS\nRCMMD\nRCMGL\nRCM\nLexM\nMCSM\nAMD\nSymAMD\nAMF\nMF\nMMD\nMETIS\nSpectral\nBT\nSAT\nMinimalChordal\nCompositeRotations\nRuleReduction\nComponentReduction\npermutation\nmcs","category":"page"},{"location":"api/#CliqueTrees.EliminationAlgorithm","page":"Library Reference","title":"CliqueTrees.EliminationAlgorithm","text":"EliminationAlgorithm\n\nA graph elimination algorithm computes a permutation of the vertices of a graph, which induces a chordal completion of the graph. The algorithms below generally seek to minimize the fill (number of edges) or width (largest clique) of the completed graph.\n\ntype name time space\nBFS breadth-first search O(m + n) O(n)\nMCS maximum cardinality search O(m + n) O(n)\nLexBFS lexicographic breadth-first search O(m + n) O(m + n)\nRCMMD reverse Cuthill-Mckee (minimum degree) O(m + n) O(m + n)\nRCMGL reverse Cuthill-Mckee (George-Liu) O(m + n) O(m + n)\nMCSM maximum cardinality search (minimal) O(mn) O(n)\nLexM lexicographic breadth-first search (minimal) O(mn) O(n)\nAMF approximate minimum fill O(mn) O(m + n)\nMF minimum fill O(mn²) \nMMD multiple minimum degree O(mn²) O(m + n)\nMinimalChordal MinimalChordal  \nCompositeRotations elimination tree rotation O(m + n) O(m + n)\nRuleReduction treewith-safe rule-based reduction  \nComponentReduction connected component reduction  \n\nThe following additional algorithms are implemented as package extensions and require loading an additional package.\n\ntype name time space package\nAMD approximate minimum degree O(mn) O(m + n) AMD.jl\nSymAMD column approximate minimum degree O(mn) O(m + n) AMD.jl\nMETIS multilevel nested dissection   Metis.jl\nSpectral spectral ordering   Laplacians.jl\nBT Bouchitte-Todinca   TreeWidthSolver.jl\nSAT SAT encoding (picosat)   PicoSAT_jll.jl\nSAT SAT encoding (cryptominisat)   CryptoMiniSat_jll.jl\n\nTriangulation Recognition Heuristics\n\nMCS\nLexBFS\nMCSM\nLexM\n\nThese algorithms are guaranteed to compute perfect elimination orderings for chordal graphs. MCSM and LexM are variants of MCS and LexBFS that compute minimal orderings. The Lex algorithms were pubished first, and the MCS algorithms were introducd later as simplications. In practice, these algorithms work poorly on non-chordal graphs.\n\nBandwidth and Envelope Reduction Heuristics\n\nRCMMD\nRCMGL\nSpectral\n\nThese algorithms seek to minimize the bandwidth and profile of the permuted graph, quantities that upper bound the width and fill of theinduced chordal completion. RCMMD and RCMGL are two variants of the reverse Cuthill-McKee algorithm, a type of breadth-first search. They differ in in their choice of starting vertex. In practice, these algorithms work better than the triangulation recognition heuristics and worse than the greedy heuristics.\n\nGreedy Heuristics\n\nMMD\nMF\nAMD\nSymAMD\nAMF\n\nThese algorithms simulate the elimination process, greedity selecting vertices to eliminate. MMD selects a vertex of minimum degree, and MF selects a vertex that induces the least fill. Updating the degree or fill of every vertex after elimination is costly; the algorithms AMD, SymAMD, and AMF are relaxations that work by approximating these values. The AMD algorithm is the state-of-the-practice for sparse matrix ordering.\n\nExact Treewidth Algorithms\n\nBT\nSAT\n\nThese algorithm minimizes the treewidth of the completed graph.\n\nwarning: Warning\nThis is an NP-hard problem. I recommend wrapping exact treewidth algorithms with preprocessors like RuleReduction or ComponentReduction. \n\nMeta Algorithms\n\nMinimalChordal\nCompositeRotations\nRuleReduction\nComponentReduction\n\nThese algorithms are parametrized by another algorithm and work by transforming its input or output. \n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.PermutationOrAlgorithm","page":"Library Reference","title":"CliqueTrees.PermutationOrAlgorithm","text":"PermutationOrAlgorithm = Union{AbstractVector, EliminationAlgorithm}\n\nEither a permutation or an algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.DEFAULT_ELIMINATION_ALGORITHM","page":"Library Reference","title":"CliqueTrees.DEFAULT_ELIMINATION_ALGORITHM","text":"DEFAULT_ELIMINATION_ALGORITHM = MMD()\n\nThe default algorithm.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.BFS","page":"Library Reference","title":"CliqueTrees.BFS","text":"BFS <: EliminationAlgorithm\n\nBFS()\n\nThe breadth-first search algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MCS","page":"Library Reference","title":"CliqueTrees.MCS","text":"MCS <: EliminationAlgorithm\n\nMCS()\n\nThe maximum cardinality search algorithm.\n\nReferences\n\nTarjan, Robert E., and Mihalis Yannakakis. \"Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs.\" SIAM Journal on Computing 13.3 (1984): 566-579.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LexBFS","page":"Library Reference","title":"CliqueTrees.LexBFS","text":"LexBFS <: EliminationAlgorithm\n\nLexBFS()\n\nThe lexicographic breadth-first-search algorithm.\n\nReferences\n\nRose, Donald J., R. Endre Tarjan, and George S. Lueker. \"Algorithmic aspects of vertex elimination on graphs.\" SIAM Journal on Computing 5.2 (1976): 266-283.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCMMD","page":"Library Reference","title":"CliqueTrees.RCMMD","text":"RCMMD{A} <: EliminationAlgorithm\n\nRCMMD(alg::Algorithm)\n\nRCMMD()\n\nThe reverse Cuthill-McKee algorithm. An initial vertex is selected using the minimum degree heuristic.\n\nParameters\n\nalg: sorting algorithm\n\nReferences\n\nCuthill, Elizabeth, and James McKee. \"Reducing the bandwidth of sparse symmetric matrices.\" Proceedings of the 1969 24th National Conference. 1969.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCMGL","page":"Library Reference","title":"CliqueTrees.RCMGL","text":"RCMGL{A} <: EliminationAlgorithm\n\nRCMGL(alg::Algorithm)\n\nRCMGL()\n\nThe reverse Cuthill-McKee algorithm. An initial vertex is selected using George and Liu's variant of the GPS algorithm.\n\nParameters\n\nalg: sorting algorithm\n\nReferences\n\nCuthill, Elizabeth, and James McKee. \"Reducing the bandwidth of sparse symmetric matrices.\" Proceedings of the 1969 24th National Conference. 1969.\nGeorge, Alan, and Joseph WH Liu. \"An implementation of a pseudoperipheral node finder.\" ACM Transactions on Mathematical Software (TOMS) 5.3 (1979): 284-295.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCM","page":"Library Reference","title":"CliqueTrees.RCM","text":"RCM = RCMGL\n\nThe default variant of the reverse Cuthill-Mckee algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LexM","page":"Library Reference","title":"CliqueTrees.LexM","text":"LexM <: EliminationAlgorithm\n\nLexM()\n\nA minimal variant of the lexicographic breadth-first-search algorithm.\n\nReferences\n\nRose, Donald J., R. Endre Tarjan, and George S. Lueker. \"Algorithmic aspects of vertex elimination on graphs.\" SIAM Journal on Computing 5.2 (1976): 266-283.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MCSM","page":"Library Reference","title":"CliqueTrees.MCSM","text":"MCSM <: EliminationAlgorithm\n\nMCSM()\n\nA minimal variant of the maximal cardinality search algorithm.\n\nReferences\n\nBerry, Anne, et al. \"Maximum cardinality search for computing minimal triangulations of graphs.\" Algorithmica 39 (2004): 287-298.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.AMD","page":"Library Reference","title":"CliqueTrees.AMD","text":"AMD <: EliminationAlgorithm\n\nAMD(; dense=10.0, aggressive=1.0)\n\nThe approximate minimum degree algorithm.\n\nParameters\n\ndense: dense row parameter\naggressive: aggressive absorption\n\nReferences\n\nAmestoy, Patrick R., Timothy A. Davis, and Iain S. Duff. \"An approximate minimum degree ordering algorithm.\" SIAM Journal on Matrix Analysis and Applications 17.4 (1996): 886-905.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SymAMD","page":"Library Reference","title":"CliqueTrees.SymAMD","text":"SymAMD <: EliminationAlgorithm\n\nSymAMD(; dense_row=10.0, dense_col=10.0, aggressive=1.0)\n\nThe column approximate minimum degree algorithm.\n\nParameters\n\ndense_row: dense row parameter\ndense_column: dense column parameter\naggressive: aggressive absorption\n\nReferences\n\nDavis, Timothy A., et al. \"A column approximate minimum degree ordering algorithm.\" ACM Transactions on Mathematical Software (TOMS) 30.3 (2004): 353-376.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.AMF","page":"Library Reference","title":"CliqueTrees.AMF","text":"AMF <: EliminationAlgorithm\n\nAMF(; speed=1)\n\nThe approximate minimum fill algorithm.\n\nParameters\n\nspeed: fill approximation strategy (1, 2, or, 3)\n\nReferences\n\nRothberg, Edward, and Stanley C. Eisenstat. \"Node selection strategies for bottom-up sparse matrix ordering.\" SIAM Journal on Matrix Analysis and Applications 19.3 (1998): 682-695.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MF","page":"Library Reference","title":"CliqueTrees.MF","text":"MF <: EliminationAlgorithm\n\nMF()\n\nThe greedy minimum fill algorithm.\n\nReferences\n\nTinney, William F., and John W. Walker. \"Direct solutions of sparse network equations by optimally ordered triangular factorization.\" Proceedings of the IEEE 55.11 (1967): 1801-1809.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MMD","page":"Library Reference","title":"CliqueTrees.MMD","text":"MMD <: EliminationAlgorithm\n\nMMD(; delta=0)\n\nThe multiple minimum degree algorithm.\n\nParameters\n\ndelta: tolerance for multiple elimination\n\nReferences\n\nLiu, Joseph WH. \"Modification of the minimum-degree algorithm by multiple elimination.\" ACM Transactions on Mathematical Software (TOMS) 11.2 (1985): 141-153.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.METIS","page":"Library Reference","title":"CliqueTrees.METIS","text":"METIS <: EliminationAlgorithm\n\nMETIS(; ctype=-1, rtype=-1, nseps=-1, niter=-1, seed=-1,\n        compress=-1, ccorder=-1, pfactor=-1, ufactor=-1)\n\nThe multilevel nested dissection algorithm implemented in METIS.\n\nParameters\n\nctype: matching scheme to be used during coarsening\nrtype: algorithm used for refinement\nnseps: number of different separators computed at each level of nested dissection\nniter: number of iterations for refinement algorithm at each stage of the uncoarsening process\nseed: random seed\ncompress: whether to combine vertices with identical adjacency lists\nccorder: whether to order connected components separately\npfactor: minimum degree of vertices that will be ordered last\nufactor: maximum allowed load imbalance partitions\n\nReferences\n\nKarypis, George, and Vipin Kumar. \"A fast and high quality multilevel scheme for partitioning irregular graphs.\" SIAM Journal on Scientific Computing 20.1 (1998): 359-392.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Spectral","page":"Library Reference","title":"CliqueTrees.Spectral","text":"Spectral <: EliminationAlgorithm\n\nSpectral(; tol=0.0)\n\nThe spectral ordering algorithm only works on connected graphs. In order to use it, import the package Laplacians.\n\nParameters\n\ntol: tolerance for convergence\n\nReferences\n\nBarnard, Stephen T., Alex Pothen, and Horst D. Simon. \"A spectral algorithm for envelope reduction of sparse matrices.\" Proceedings of the 1993 ACM/IEEE Conference on Supercomputing. 1993.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.BT","page":"Library Reference","title":"CliqueTrees.BT","text":"BT <: EliminationAlgorithm\n\nBT()\n\nThe Bouchitte-Todinca algorithm.\n\nReferences\n\nKorhonen, Tuukka, Jeremias Berg, and Matti Järvisalo. \"Solving Graph Problems via Potential Maximal Cliques: An Experimental Evaluation of the Bouchitté-Todinca Algorithm.\" Journal of Experimental Algorithmics (JEA) 24 (2019): 1-19.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SAT","page":"Library Reference","title":"CliqueTrees.SAT","text":"SAT <: EliminationAlgorithm\n\nSAT{Handle}(lb::LowerBoundAlgorithn, ub::PermutationOrAlgorithm)\n\nSAT{Handle}()\n\nCompute a minimum-treewidth permutation using a SAT solver.\n\nParameters\n\nHandle: solver module (either PicoSAT_jll or CryptoMiniSat_jll)\nlb: lower bound algorithm\nub: upper bound algorithm\n\nReferences\n\nSamer, Marko, and Helmut Veith. \"Encoding treewidth into SAT.\" Theory and Applications of Satisfiability Testing-SAT 2009: 12th International Conference, SAT 2009, Swansea, UK, June 30-July 3, 2009. Proceedings 12. Springer Berlin Heidelberg, 2009.\nBerg, Jeremias, and Matti Järvisalo. \"SAT-based approaches to treewidth computation: An evaluation.\" 2014 IEEE 26th international conference on tools with artificial intelligence. IEEE, 2014.\nBannach, Max, Sebastian Berndt, and Thorsten Ehlers. \"Jdrasil: A modular library for computing tree decompositions.\" 16th International Symposium on Experimental Algorithms (SEA 2017). Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2017.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MinimalChordal","page":"Library Reference","title":"CliqueTrees.MinimalChordal","text":"MinimalChordal{A} <: EliminationAlgorithm\n\nMinimalChordal(alg::PermutationOrAlgorithm)\n\nMinimalChordal()\n\nEvaluate an elimination algorithm, and them improve its output using the MinimalChordal algorithm. The result is guaranteed to be minimal.\n\nParameters\n\nalg: elimination algorithm\n\nReferences\n\nBlair, Jean RS, Pinar Heggernes, and Jan Arne Telle. \"A practical algorithm for making filled graphs minimal.\" Theoretical Computer Science 250.1-2 (2001): 125-141.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CompositeRotations","page":"Library Reference","title":"CliqueTrees.CompositeRotations","text":"CompositeRotations{C, A} <: EliminationAlgorithm\n\nCompositeRotations(clique::AbstractVector, alg::EliminationAlgorithm)\n\nCompositeRotations(clique::AbstractVector)\n\nEvaluate an eliminaton algorithm, ensuring that the given clique is at the end of the ordering.\n\nParameters\n\nclique: clique\nalg: elimination algorithm\n\nReferences\n\nLiu, Joseph WH. \"Equivalent sparse matrix reordering by elimination tree rotations.\" Siam Journal on Scientific and Statistical Computing 9.3 (1988): 424-444.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RuleReduction","page":"Library Reference","title":"CliqueTrees.RuleReduction","text":"RuleReduction{A} <: EliminationAlgorithm\n\nRuleReduction(alg::PermutationOrAlgororithm)\n\nRuleReduction()\n\nPreprocess a graph using safe reduction rules.\n\nParameters\n\nalg: elimination algorithm\n\nReferences\n\nBodlaender, Hans L., Arie M.C.A. Koster, and Frank van den Eijkhof. \"Preprocessing rules for triangulation of probabilistic networks.\" Computational Intelligence 21.3 (2005): 286-305.\nvan den Eijkhof, Frank, Hans L. Bodlaender, and Arie M.C.A. Koster. \"Safe reduction rules for weighted treewidth.\" Algorithmica 47 (2007): 139-158. \n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.ComponentReduction","page":"Library Reference","title":"CliqueTrees.ComponentReduction","text":"ComponentReduction{A} <: EliminationAlgorithm\n\nComponentReduction(alg::PermutationOrAlgorithm)\n\nComponentReduction()\n\nApply an elimination algorithm to each connected component of a graph.\n\nParameters\n\nalg: elimination algorithm\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.permutation","page":"Library Reference","title":"CliqueTrees.permutation","text":"permutation([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nConstruct a fill-reducing permutation of the vertices of a simple graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> order, index = permutation(graph);\n\njulia> order\n8-element Vector{Int64}:\n 4\n 1\n 2\n 8\n 5\n 3\n 6\n 7\n\njulia> index == invperm(order)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.mcs","page":"Library Reference","title":"CliqueTrees.mcs","text":"mcs(graph[, clique])\n\nPerform a maximum cardinality search, optionally specifying a clique to be ordered last. Returns the inverse permutation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Supernodes","page":"Library Reference","title":"Supernodes","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"SupernodeType\nDEFAULT_SUPERNODE_TYPE\nNodal\nMaximal\nFundamental","category":"page"},{"location":"api/#CliqueTrees.SupernodeType","page":"Library Reference","title":"CliqueTrees.SupernodeType","text":"SupernodeType\n\nA type of supernode partition. The options are\n\ntype name\nNodal nodal supernode partition\nMaximal maximal supernode partition\nFundamental fundamental supernode partition\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.DEFAULT_SUPERNODE_TYPE","page":"Library Reference","title":"CliqueTrees.DEFAULT_SUPERNODE_TYPE","text":"DEFAULT_SUPERNODE_TYPE = Maximal()\n\nThe default supernode partition.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.Nodal","page":"Library Reference","title":"CliqueTrees.Nodal","text":"Nodal <: SupernodeType\n\nA nodal  supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Maximal","page":"Library Reference","title":"CliqueTrees.Maximal","text":"Maximal <: SupernodeType\n\nA maximal supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Fundamental","page":"Library Reference","title":"CliqueTrees.Fundamental","text":"Fundamental <: SupernodeType\n\nA fundamental supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#Linked-Lists","page":"Library Reference","title":"Linked Lists","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"SinglyLinkedList","category":"page"},{"location":"api/#CliqueTrees.SinglyLinkedList","page":"Library Reference","title":"CliqueTrees.SinglyLinkedList","text":"SinglyLinkedList{I, Head, Next} <: AbstractLinkedList{I}\n\nSinglyLinkedList{I}(n::Integer)\n\nA singly linked list of distinct natural numbers. This type supports the iteration interface.\n\njulia> using CliqueTrees\n\njulia> list = SinglyLinkedList{Int}(10)\nSinglyLinkedList{Int64, Array{Int64, 0}, Vector{Int64}}:\n\njulia> pushfirst!(list, 4, 5, 6, 7, 8, 9)\nSinglyLinkedList{Int64, Array{Int64, 0}, Vector{Int64}}:\n 4\n 5\n 6\n 7\n 8\n ⋮\n\njulia> collect(list)\n6-element Vector{Int64}:\n 4\n 5\n 6\n 7\n 8\n 9\n\n\n\n\n\n","category":"type"},{"location":"api/#Trees","page":"Library Reference","title":"Trees","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AbstractTree\nrootindices\nfirstchildindex\nancestorindices","category":"page"},{"location":"api/#CliqueTrees.AbstractTree","page":"Library Reference","title":"CliqueTrees.AbstractTree","text":"AbstractTree{V} = Union{Tree{V}, SupernodeTree{V}, CliqueTree{V}}\n\nA rooted forest. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.rootindices","page":"Library Reference","title":"CliqueTrees.rootindices","text":"rootindices(tree::AbstractTree)\n\nGet the roots of a rooted forest.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.firstchildindex","page":"Library Reference","title":"CliqueTrees.firstchildindex","text":"firstchildindex(tree::AbstractTree, i::Integer)\n\nGet the first child of node i. Returns nothing if i is a leaf.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.ancestorindices","page":"Library Reference","title":"CliqueTrees.ancestorindices","text":"ancestorindices(tree::AbstractTree, i::Integer)\n\nGet the proper ancestors of node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Trees-2","page":"Library Reference","title":"Trees","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Tree\neliminationtree","category":"page"},{"location":"api/#CliqueTrees.Tree","page":"Library Reference","title":"CliqueTrees.Tree","text":"Tree{V} <: AbstractUnitRange{V}\n\nTree(tree::AbstractTree)\n\nTree{V}(tree::AbstractTree) where V\n\nA rooted forest with vertices of type V. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.eliminationtree","page":"Library Reference","title":"CliqueTrees.eliminationtree","text":"eliminationtree([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nConstruct a tree-depth decomposition of a simple graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = eliminationtree(graph);\n\njulia> tree\n8-element Tree{Int64}:\n 8\n └─ 7\n    ├─ 5\n    └─ 6\n       ├─ 1\n       ├─ 3\n       │  └─ 2\n       └─ 4\n\n\n\n\n\n","category":"function"},{"location":"api/#Supernode-Trees","page":"Library Reference","title":"Supernode Trees","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"SupernodeTree\nsupernodetree","category":"page"},{"location":"api/#CliqueTrees.SupernodeTree","page":"Library Reference","title":"CliqueTrees.SupernodeTree","text":"SupernodeTree{V} <: AbstractVector{UnitRange{V}}\n\nA supernodal elimination tree with vertices of type V. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.supernodetree","page":"Library Reference","title":"CliqueTrees.supernodetree","text":"supernodetree(graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE)\n\nConstruct a supernodal elimination tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clique-Trees","page":"Library Reference","title":"Clique Trees","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Clique\nCliqueTree\ncliquetree\ntreewidth\nseparator\nresidual","category":"page"},{"location":"api/#CliqueTrees.Clique","page":"Library Reference","title":"CliqueTrees.Clique","text":"Clique{V, E} <: AbstractVector{V}\n\nA clique of a clique tree.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CliqueTree","page":"Library Reference","title":"CliqueTrees.CliqueTree","text":"CliqueTree{V, E} <: AbstractVector{Clique{V, E}}\n\nA clique tree with vertices of type V and edges of type E. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.cliquetree","page":"Library Reference","title":"CliqueTrees.cliquetree","text":"cliquetree([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE)\n\nConstruct a tree decomposition of a simple graph. The vertices of the graph are first ordered by a fill-reducing permutation computed by the algorithm alg. The size of the resulting decomposition is determined by the supernode partition snd.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = cliquetree(graph);\n\njulia> tree\n6-element CliqueTree{Int64, Int64}:\n [6, 7, 8]\n └─ [5, 7, 8]\n    ├─ [1, 5]\n    ├─ [3, 5, 7]\n    │  └─ [2, 3]\n    └─ [4, 5, 8]\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.treewidth","page":"Library Reference","title":"CliqueTrees.treewidth","text":"treewidth([weights, ]tree::CliqueTree)\n\nCompute the width of a clique tree.\n\n\n\n\n\ntreewidth([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nCompute an upper bound to the tree width of a simple graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.separator","page":"Library Reference","title":"CliqueTrees.separator","text":"separator(clique::Clique)\n\nGet the separator of a clique.\n\n\n\n\n\nseparator(tree::CliqueTree, i::Integer)\n\nGet the separator at node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.residual","page":"Library Reference","title":"CliqueTrees.residual","text":"residual(clique::Clique)\n\nGet the residual of a clique.\n\n\n\n\n\nresidual(tree::CliqueTree, i::Integer)\n\nGet the residual at node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Filled-Graphs","page":"Library Reference","title":"Filled Graphs","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"FilledGraph\nischordal\nisperfect","category":"page"},{"location":"api/#CliqueTrees.FilledGraph","page":"Library Reference","title":"CliqueTrees.FilledGraph","text":"FilledGraph{V, E} <: AbstractGraph{V}\n\nA filled graph.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.ischordal","page":"Library Reference","title":"CliqueTrees.ischordal","text":"ischordal(graph)\n\nDetermine whether a simple graph is chordal.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.isperfect","page":"Library Reference","title":"CliqueTrees.isperfect","text":"isperfect(graph, order::AbstractVector[, index::AbstractVector])\n\nDetermine whether an fill-reducing permutation is perfect.\n\n\n\n\n\n","category":"function"},{"location":"#CliqueTrees.jl","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"CliqueTrees.jl implements clique trees in Julia. You can use it to construct tree decompositions and chordal completions of graphs.","category":"page"},{"location":"#Installation","page":"CliqueTrees.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"To install CliqueTrees.jl, enter the Pkg REPL by typing ] and run the following command.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"pkg> add CliqueTrees","category":"page"},{"location":"#Basic-Usage","page":"CliqueTrees.jl","title":"Basic Usage","text":"","category":"section"},{"location":"#Tree-Decompositions","page":"CliqueTrees.jl","title":"Tree Decompositions","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"The function cliquetree computes tree decompositions.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"julia> using CliqueTrees, LinearAlgebra, SparseArrays\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = cliquetree(graph);\n\njulia> tree\n6-element CliqueTree{Int64, Int64}:\n [6, 7, 8]\n └─ [5, 7, 8]\n    ├─ [1, 5]\n    ├─ [3, 5, 7]\n    │  └─ [2, 3]\n    └─ [4, 5, 8]","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"The clique tree tree is a tree decomposition of the permuted graph graph[label, label]. A clique tree is a vector of cliques, so you can retrieve the clique at node 4 by typing tree[4].","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"julia> tree[4]\n3-element Clique{Int64, Int64}:\n 4\n 5\n 8","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"warning: Warning\nThe numbers in each clique are vertices of the permuted graph graph[label, label]. You can see the vertices of the original graph by typingjulia> label[tree[4]]\n3-element Vector{Int64}:\n8\n3\n7Notice that the clique is no longer sorted.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"The width of a clique tree is computed by the function treewidth.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"julia> treewidth(tree)\n2","category":"page"},{"location":"#Chordal-Completions","page":"CliqueTrees.jl","title":"Chordal Completions","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"Clique trees can be used to construct chordal completions.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"julia> filledgraph = FilledGraph(tree)\n{8, 11} FilledGraph{Int64, Int64}\n\njulia> sparse(filledgraph)\n8×8 SparseMatrixCSC{Bool, Int64} with 11 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  1  1  ⋅","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"The graph filledgraph is ordered: its edges are directed from lower to higher vertices. The underlying undirected graph is a chordal completion of the permuted graph graph[label, label].","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"julia> chordalgraph = Symmetric(sparse(filledgraph), :L)\n8×8 Symmetric{Bool, SparseMatrixCSC{Bool, Int64}}:\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  1  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  1\n 1  ⋅  1  1  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  1  ⋅  1  1  ⋅  1\n ⋅  ⋅  ⋅  1  1  1  1  ⋅\n\njulia> ischordal(graph)\nfalse\n\njulia> ischordal(chordalgraph)\ntrue\n\njulia> all(graph[label, label] .<= chordalgraph)\ntrue","category":"page"},{"location":"#Graphs","page":"CliqueTrees.jl","title":"Graphs","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"Users can input graphs as adjacency matrices. Additionally, CliqueTrees.jl supports the HasGraph type from Catlab.jl and the AbstractGraph type from Graphs.jl. Instances of the latter should implement the following subset of the abstract graph interface.","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"is_directed\nne\nnv\noutneighbors\nvertices","category":"page"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"Self-edges are always ignored.","category":"page"},{"location":"#References","page":"CliqueTrees.jl","title":"References","text":"","category":"section"},{"location":"","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"CliqueTrees.jl was inspired by the book Chordal Graphs and Semidefinite Optimization by Vandenberghe and Andersen.","category":"page"}]
}
