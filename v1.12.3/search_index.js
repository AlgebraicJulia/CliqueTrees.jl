var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Lower-Bound-Algorithms","page":"Library Reference","title":"Lower Bound Algorithms","text":"","category":"section"},{"location":"api/#Dissection-Algorithms","page":"Library Reference","title":"Dissection Algorithms","text":"","category":"section"},{"location":"api/#Elimination-Algorithms","page":"Library Reference","title":"Elimination Algorithms","text":"","category":"section"},{"location":"api/#Supernodes","page":"Library Reference","title":"Supernodes","text":"","category":"section"},{"location":"api/#Trees","page":"Library Reference","title":"Trees","text":"","category":"section"},{"location":"api/#Trees-2","page":"Library Reference","title":"Trees","text":"","category":"section"},{"location":"api/#Supernode-Trees","page":"Library Reference","title":"Supernode Trees","text":"","category":"section"},{"location":"api/#Clique-Trees","page":"Library Reference","title":"Clique Trees","text":"","category":"section"},{"location":"api/#Filled-Graphs","page":"Library Reference","title":"Filled Graphs","text":"","category":"section"},{"location":"api/#Matrix-Factorization","page":"Library Reference","title":"Matrix Factorization","text":"","category":"section"},{"location":"api/#CliqueTrees.LowerBoundAlgorithm","page":"Library Reference","title":"CliqueTrees.LowerBoundAlgorithm","text":"LowerBoundAlgorithm\n\nAn algorithm for computing a lower bound to the treewidth of a graph. The options are\n\ntype name time space\nMMW minor-min-width  O(m + n)\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MMW","page":"Library Reference","title":"CliqueTrees.MMW","text":"MMW{S} <: LowerBoundAlgorithm\n\nMMW{S}()\n\nThe minor-min-width heuristic.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = MMW{1}()\nMMW{1}\n\njulia> lowerbound(graph; alg)\n2\n\nParameters\n\nS: strategy\n1: min-d (fast)\n2: max-d (fast)\n3: least-c (slow)\n\nReferences\n\nGogate, Vibhav, and Rina Dechter. \"A complete anytime algorithm for treewidth.\" Proceedings of the 20th conference on Uncertainty in artificial intelligence. 2004.\nBodlaender, Hans, Thomas Wolle, and Arie Koster. \"Contraction and treewidth lower bounds.\" Journal of Graph Algorithms and Applications 10.1 (2006): 5-49.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.lowerbound","page":"Library Reference","title":"CliqueTrees.lowerbound","text":"lowerbound([weights, ]graph;\n    alg::WidthOrAlgorithm=DEFAULT_LOWER_BOUND_ALGORITHM)\n\nCompute a lower bound to the treewidth of a graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> lowerbound(graph)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.DEFAULT_LOWER_BOUND_ALGORITHM","page":"Library Reference","title":"CliqueTrees.DEFAULT_LOWER_BOUND_ALGORITHM","text":"DEFAULT_LOWER_BOUND_ALGORITHM = MMW()\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.DissectionAlgorithm","page":"Library Reference","title":"CliqueTrees.DissectionAlgorithm","text":"DissectionAlgorithm\n\nA vertex separator algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.METISND","page":"Library Reference","title":"CliqueTrees.METISND","text":"METISND <: DissectionAlgorithm\n\nMETISND(; nseps=-1, seed=-1)\n\nCompute a vertex separator using the graph partitioning library METIS.\n\nParameters\n\nnseps: number of different separators computed at each level of nested dissection\nseed: random seed\n\nReferences\n\nKarypis, George, and Vipin Kumar. \"A fast and high quality multilevel scheme for partitioning irregular graphs.\" SIAM Journal on Scientific Computing 20.1 (1998): 359-392.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.KaHyParND","page":"Library Reference","title":"CliqueTrees.KaHyParND","text":"KaHyParND{O} <: DissectionAlgorithm\n\nKaHyParND(order; beta=1.0)\n\nCompute a vertex separator using the hypergraph partitioning library KaHyPar. A β-quasi-clique cover is constructed using a greedy algorithm controlled by the parameters order and beta.\n\nParameters\n\norder: tie breaking strategy (Forward or Reverse).\nbeta: quasi-clique parameter\n\nReferences\n\nÇatalyürek, Ümit V., Cevdet Aykanat, and Enver Kayaaslan. \"Hypergraph partitioning-based fill-reducing ordering for symmetric matrices.\" SIAM Journal on Scientific Computing 33.4 (2011): 1996-2023.\nKaya, Oguz, et al. \"Fill-in reduction in sparse matrix factorizations using hypergraphs\".\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.DEFAULT_DISSECTION_ALGORITHM","page":"Library Reference","title":"CliqueTrees.DEFAULT_DISSECTION_ALGORITHM","text":"DEFAULT_DISSECTION_ALGORITHM = METISND()\n\nThe default dissection algorithm.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.EliminationAlgorithm","page":"Library Reference","title":"CliqueTrees.EliminationAlgorithm","text":"EliminationAlgorithm\n\nA graph elimination algorithm computes a total ordering of the vertices of a graph.  The algorithms implemented in CliqueTrees.jl can be divided into five categories.\n\ntriangulation recognition algorithms\nbandwidth minimization algorithms\nlocal algorithms\nglobal algorithms\nexact treewidth algorithms\n\nTriangulation Recognition Algorithms\n\ntype name time space package\nMCS maximum cardinality search O(m + n) O(n) \nLexBFS lexicographic breadth-first search O(m + n) O(m + n) \nMCSM maximum cardinality search (minimal) O(mn) O(n) \nLexM lexicographic breadth-first search (minimal) O(mn) O(n) \n\nThese algorithms will compute perfect orderings when applied to chordal graphs.\n\nBandwidth Minimization Algorithms\n\ntype name time space package\nRCMMD reverse Cuthill-Mckee (minimum degree) O(m + n) O(m + n) \nRCMGL reverse Cuthill-Mckee (George-Liu) O(m + n) O(m + n) \n\nThese algorithms try to minimize the bandwidth and envelope of the ordered graph.\n\nLocal Algorithms\n\ntype name time space package\nMMD multiple minimum degree O(mn²) O(m + n) \nMF minimum fill O(mn²)  \nAMD approximate minimum degree O(mn) O(m + n) AMD.jl\nSymAMD column approximate minimum degree O(mn) O(m + n) AMD.jl\nAMF approximate minimum fill O(mn) O(m + n) \n\nThese algorithms simulate the graph elimination process, greedily eliminating vertices that minimize a cost function. They are faster then the global algorithms, but have worse results.\n\nGlobal Algorithms\n\ntype name time space package\nMETIS nested dissection   Metis.jl\nND nested dissection   \n\nThese algorithms recursively partition a graph, then call a local algorithm on the leaves. These are slower than the local algorithms, but have better results.\n\nExact Treewidth Algorithms\n\ntype name time space package\nBT Bouchitte-Todinca   TreeWidthSolver.jl\nSAT SAT encoding   \n\nThe orderings computed by these algorithms induce minimum-width tree decompositions.\n\nwarning: Warning\nExact treewidth is an NP-hard problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.PermutationOrAlgorithm","page":"Library Reference","title":"CliqueTrees.PermutationOrAlgorithm","text":"PermutationOrAlgorithm = Union{\n    AbstractVector,\n    Tuple{AbstractVector, AbstractVector},\n    EliminationAlgorithm,\n}\n\nEither a permutation or an algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.DEFAULT_ELIMINATION_ALGORITHM","page":"Library Reference","title":"CliqueTrees.DEFAULT_ELIMINATION_ALGORITHM","text":"DEFAULT_ELIMINATION_ALGORITHM = AMF()\n\nThe default algorithm.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.BFS","page":"Library Reference","title":"CliqueTrees.BFS","text":"BFS <: EliminationAlgorithm\n\nBFS()\n\nThe breadth-first search algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = BFS()\nBFS\n\njulia> treewidth(graph; alg)\n2\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MCS","page":"Library Reference","title":"CliqueTrees.MCS","text":"MCS <: EliminationAlgorithm\n\nMCS()\n\nThe maximum cardinality search algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = MCS()\nMCS\n\njulia> treewidth(graph; alg)\n3\n\nReferences\n\nTarjan, Robert E., and Mihalis Yannakakis. \"Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs.\" SIAM Journal on Computing 13.3 (1984): 566-579.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LexBFS","page":"Library Reference","title":"CliqueTrees.LexBFS","text":"LexBFS <: EliminationAlgorithm\n\nLexBFS()\n\nThe lexicographic breadth-first-search algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = LexBFS()\nLexBFS\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nRose, Donald J., R. Endre Tarjan, and George S. Lueker. \"Algorithmic aspects of vertex elimination on graphs.\" SIAM Journal on Computing 5.2 (1976): 266-283.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCMMD","page":"Library Reference","title":"CliqueTrees.RCMMD","text":"RCMMD{A} <: EliminationAlgorithm\n\nRCMMD(alg::Algorithm)\n\nRCMMD()\n\nThe reverse Cuthill-McKee algorithm. An initial vertex is selected using the minimum degree heuristic.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = RCMMD(QuickSort)\nRCMMD:\n    Base.Sort.QuickSortAlg()\n\njulia> treewidth(graph; alg)\n3\n\nParameters\n\nalg: sorting algorithm\n\nReferences\n\nCuthill, Elizabeth, and James McKee. \"Reducing the bandwidth of sparse symmetric matrices.\" Proceedings of the 1969 24th National Conference. 1969.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCMGL","page":"Library Reference","title":"CliqueTrees.RCMGL","text":"RCMGL{A} <: EliminationAlgorithm\n\nRCMGL(alg::Algorithm)\n\nRCMGL()\n\nThe reverse Cuthill-McKee algorithm. An initial vertex is selected using George and Liu's variant of the GPS algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = RCMGL(QuickSort)\nRCMGL:\n    Base.Sort.QuickSortAlg()\n\njulia> treewidth(graph; alg)\n3\n\nParameters\n\nalg: sorting algorithm\n\nReferences\n\nCuthill, Elizabeth, and James McKee. \"Reducing the bandwidth of sparse symmetric matrices.\" Proceedings of the 1969 24th National Conference. 1969.\nGeorge, Alan, and Joseph WH Liu. \"An implementation of a pseudoperipheral node finder.\" ACM Transactions on Mathematical Software (TOMS) 5.3 (1979): 284-295.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.RCM","page":"Library Reference","title":"CliqueTrees.RCM","text":"RCM = RCMGL\n\nThe default variant of the reverse Cuthill-Mckee algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LexM","page":"Library Reference","title":"CliqueTrees.LexM","text":"LexM <: EliminationAlgorithm\n\nLexM()\n\nA minimal variant of the lexicographic breadth-first-search algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = LexM()\nLexM\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nRose, Donald J., R. Endre Tarjan, and George S. Lueker. \"Algorithmic aspects of vertex elimination on graphs.\" SIAM Journal on Computing 5.2 (1976): 266-283.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MCSM","page":"Library Reference","title":"CliqueTrees.MCSM","text":"MCSM <: EliminationAlgorithm\n\nMCSM()\n\nA minimal variant of the maximal cardinality search algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = MCSM()\nMCSM\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nBerry, Anne, et al. \"Maximum cardinality search for computing minimal triangulations of graphs.\" Algorithmica 39 (2004): 287-298.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.AMD","page":"Library Reference","title":"CliqueTrees.AMD","text":"AMD <: EliminationAlgorithm\n\nAMD(; dense=10.0, aggressive=1.0)\n\nThe approximate minimum degree algorithm.\n\njulia> using CliqueTrees\n\njulia> import AMD as AMDLib\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = AMD(; dense=5.0, aggressive=2.0)\nAMD:\n    dense: 5.0\n    aggressive: 2.0\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\ndense: dense row parameter\naggressive: aggressive absorption\n\nReferences\n\nAmestoy, Patrick R., Timothy A. Davis, and Iain S. Duff. \"An approximate minimum degree ordering algorithm.\" SIAM Journal on Matrix Analysis and Applications 17.4 (1996): 886-905.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SymAMD","page":"Library Reference","title":"CliqueTrees.SymAMD","text":"SymAMD <: EliminationAlgorithm\n\nSymAMD(; dense_row=10.0, dense_col=10.0, aggressive=1.0)\n\nThe column approximate minimum degree algorithm.\n\njulia> using CliqueTrees\n\njulia> import AMD as AMDLib\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = SymAMD(; dense_row=5.0, dense_col=5.0, aggressive=2.0)\nSymAMD:\n    dense_row: 5.0\n    dense_col: 5.0\n    aggressive: 2.0\n\n\njulia> treewidth(graph, alg)\n2\n\nParameters\n\ndense_row: dense row parameter\ndense_column: dense column parameter\naggressive: aggressive absorption\n\nReferences\n\nDavis, Timothy A., et al. \"A column approximate minimum degree ordering algorithm.\" ACM Transactions on Mathematical Software (TOMS) 30.3 (2004): 353-376.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.AMF","page":"Library Reference","title":"CliqueTrees.AMF","text":"AMF <: EliminationAlgorithm\n\nAMF()\n\nThe approximate minimum fill algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = AMF(; speed=2)\nAMF\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nRothberg, Edward, and Stanley C. Eisenstat. \"Node selection strategies for bottom-up sparse matrix ordering.\" SIAM Journal on Matrix Analysis and Applications 19.3 (1998): 682-695.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MF","page":"Library Reference","title":"CliqueTrees.MF","text":"MF <: EliminationAlgorithm\n\nMF()\n\nThe greedy minimum fill algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = MF\nMF\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nNg, Esmond G., and Barry W. Peyton. \"Fast implementation of the minimum local fill ordering heuristic.\" CSC14: The Sixth SIAM Workshop on Combinatorial Scientific Computing. 2014.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MMD","page":"Library Reference","title":"CliqueTrees.MMD","text":"MMD <: EliminationAlgorithm\n\nMMD(; delta=0)\n\nThe multiple minimum degree algorithm.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = MMD(; delta=1)\nMMD:\n    delta: 1\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\ndelta: tolerance for multiple elimination\n\nReferences\n\nLiu, Joseph WH. \"Modification of the minimum-degree algorithm by multiple elimination.\" ACM Transactions on Mathematical Software (TOMS) 11.2 (1985): 141-153.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.METIS","page":"Library Reference","title":"CliqueTrees.METIS","text":"METIS <: EliminationAlgorithm\n\nMETIS(; ctype=-1, rtype=-1, nseps=-1, niter=-1, seed=-1,\n        compress=-1, ccorder=-1, pfactor=-1, ufactor=-1)\n\nThe multilevel nested dissection algorithm implemented in METIS.\n\njulia> using CliqueTrees, Metis\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = METIS(ctype=Metis.METIS_CTYPE_RM)\nMETIS:\n    ctype: 0\n    rtype: -1\n    nseps: -1\n    niter: -1\n    seed: -1\n    compress: -1\n    ccorder: -1\n    pfactor: -1\n    ufactor: -1\n\n\njulia> treewidth(graph; alg)\n3\n\nParameters\n\nctype: matching scheme to be used during coarsening\nrtype: algorithm used for refinement\nnseps: number of different separators computed at each level of nested dissection\nniter: number of iterations for refinement algorithm at each stage of the uncoarsening process\nseed: random seed\ncompress: whether to combine vertices with identical adjacency lists\nccorder: whether to order connected components separately\npfactor: minimum degree of vertices that will be ordered last\nufactor: maximum allowed load imbalance partitions\n\nReferences\n\nKarypis, George, and Vipin Kumar. \"A fast and high quality multilevel scheme for partitioning irregular graphs.\" SIAM Journal on Scientific Computing 20.1 (1998): 359-392.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.ND","page":"Library Reference","title":"CliqueTrees.ND","text":"ND{S, A, D} <: EliminationAlgorithm\n\nND{S}(alg::EliminationAlgorithm, dis::DissectionAlgorithm;\n    width = 120,\n    level = 6,\n    imbalance = 130,\n)\n\nThe nested dissection algorithm. The algorithm dis is used to compute vertex separators, and the algorithm alg is called on the of the separator tree. The type parameter S controls the behavior of the algorithm: if S is equal to 1 or 2, then alg is additionally called on the branches of the separator tree. At each branch, the ordering computed by alg is compared to the ordering computed by the nested dissection algorithm, and the worse of the two is discarded.\n\n1: minimize width (slow)\n2: minimize fill (slow)\n3: no strategy (fast)\n\nCliqueTrees currently has two vertex separator algorithms, both of which require loading an external package.\n\ntype name package\nMETISND multilevel vertex separation Metis.jl\nKaHyParND multilevel hypergraph partitioning KayHyPar.jl\n\nThe algorithm KaHyParND computes a vertex separator indirectly, by partitioning a quasi-clique-cover of the original graph. The parameters width and level control the recursion depth of the algorithm, and the parameter imbalance controls the maximum imbalance of the vertex separator.\n\njulia> using CliqueTrees, Metis\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = ND{1}(MF(), METISND())\nND{1, MF, METISND}:\n    MF\n    METISND:\n        nseps: -1\n        seed: -1\n    width: 120\n    level: 6\n    imbalance: 130\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\nS: strategy\n1: minimize width (slow)\n2: minimize fill (slow)\n3: no strategy (fast)\nalg: elimination algorithm\ndis: separation algorithm\nwidth: minimum width\nlevel: maximum level\nimbalance: separator imbalance\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Spectral","page":"Library Reference","title":"CliqueTrees.Spectral","text":"Spectral <: EliminationAlgorithm\n\nSpectral(; tol=0.0)\n\nThe spectral ordering algorithm only works on connected graphs. In order to use it, import the package Laplacians.\n\njulia> using CliqueTrees, Laplacians\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = Spectral(; tol=0.001)\nSpectral:\n    tol: 0.001\n\njulia> treewidth(graph; alg)\n4\n\nParameters\n\ntol: tolerance for convergence\n\nReferences\n\nBarnard, Stephen T., Alex Pothen, and Horst D. Simon. \"A spectral algorithm for envelope reduction of sparse matrices.\" Proceedings of the 1993 ACM/IEEE Conference on Supercomputing. 1993.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.FlowCutter","page":"Library Reference","title":"CliqueTrees.FlowCutter","text":"FlowCutter <: EliminationAlgorithm\n\nFlowCutter(; time=5, seed=0)\n\nThe FlowCutter algorithm.\n\njulia> using CliqueTrees, FlowCutterPACE17_jll\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = FlowCutter(; time=2, seed=1)\nFlowCutter:\n    time: 2\n    seed: 1\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\ntime: run time\nseed: random seed\n\nReferences\n\nStrasser, Ben. \"Computing tree decompositions with flowcutter: PACE 2017 submission.\" arXiv preprint arXiv:1709.08949 (2017).\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.BT","page":"Library Reference","title":"CliqueTrees.BT","text":"BT <: EliminationAlgorithm\n\nBT()\n\nThe Bouchitte-Todinca algorithm.\n\njulia> using CliqueTrees, TreeWidthSolver\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = BT()\nBT\n\njulia> treewidth(graph; alg)\n2\n\nReferences\n\nKorhonen, Tuukka, Jeremias Berg, and Matti Järvisalo. \"Solving Graph Problems via Potential Maximal Cliques: An Experimental Evaluation of the Bouchitté-Todinca Algorithm.\" Journal of Experimental Algorithmics (JEA) 24 (2019): 1-19.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SAT","page":"Library Reference","title":"CliqueTrees.SAT","text":"SAT{H, A} <: EliminationAlgorithm\n\nSAT{H}(alg::PermutationOrAlgorithm)\n\nSAT{H}()\n\nCompute a minimum-treewidth permutation using a SAT solver.\n\njulia> using CliqueTrees, libpicosat_jll, PicoSAT_jll, CryptoMiniSat_jll, Lingeling_jll\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = SAT{libpicosat_jll}(MF()) # picosat\nSAT{libpicosat_jll, MF}:\n    MF\n\njulia> alg = SAT{PicoSAT_jll}(MF()) # picosat\nSAT{PicoSAT_jll, MF}:\n    MF\n\njulia> alg = SAT{CryptoMiniSat_jll}(MF()) # cryptominisat\nSAT{CryptoMiniSat_jll, MF}:\n    MF\n\njulia> alg = SAT{Lingeling_jll}(MMW(), MF()) # lingeling\nSAT{Lingeling_jll, MF}:\n    MF\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\nalg: elimination algorithm\n\nReferences\n\nSamer, Marko, and Helmut Veith. \"Encoding treewidth into SAT.\" Theory and Applications of Satisfiability Testing-SAT 2009: 12th International Conference, SAT 2009, Swansea, UK, June 30-July 3, 2009. Proceedings 12. Springer Berlin Heidelberg, 2009.\nBerg, Jeremias, and Matti Järvisalo. \"SAT-based approaches to treewidth computation: An evaluation.\" 2014 IEEE 26th international conference on tools with artificial intelligence. IEEE, 2014.\nBannach, Max, Sebastian Berndt, and Thorsten Ehlers. \"Jdrasil: A modular library for computing tree decompositions.\" 16th International Symposium on Experimental Algorithms (SEA 2017). Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2017.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.MinimalChordal","page":"Library Reference","title":"CliqueTrees.MinimalChordal","text":"MinimalChordal{A} <: EliminationAlgorithm\n\nMinimalChordal(alg::PermutationOrAlgorithm)\n\nMinimalChordal()\n\nEvaluate an elimination algorithm, and them improve its output using the MinimalChordal algorithm. The result is guaranteed to be minimal.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg1 = MCS()\nMCS\n\njulia> alg2 = MinimalChordal(MCS())\nMinimalChordal{MCS}:\n    MCS\n\njulia> label1, tree1 = cliquetree(graph; alg=alg1);\n\njulia> label2, tree2 = cliquetree(graph; alg=alg2);\n\njulia> FilledGraph(tree1) # more edges\n{8, 12} FilledGraph{Int64, Int64}\n\njulia> FilledGraph(tree2) # fewer edges\n{8, 11} FilledGraph{Int64, Int64}\n\nParameters\n\nalg: elimination algorithm\n\nReferences\n\nHeggernes, Pinar, and Barry W. Peyton. \"Fast computation of minimal fill inside a given elimination ordering.\" SIAM journal on matrix analysis and applications 30.4 (2009): 1424-1444.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CompositeRotations","page":"Library Reference","title":"CliqueTrees.CompositeRotations","text":"CompositeRotations{C, A} <: EliminationAlgorithm\n\nCompositeRotations(clique::AbstractVector, alg::EliminationAlgorithm)\n\nCompositeRotations(clique::AbstractVector)\n\nEvaluate an eliminaton algorithm, ensuring that the given clique is at the end of the ordering.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = CompositeRotations([2], MCS())\nCompositeRotations{Vector{Int64}, MCS}:\n    clique: [2]\n    MCS\n\njulia> order, index = permutation(graph; alg);\n\njulia> order # 2 is the last vertex in the ordering\n8-element Vector{Int64}:\n 4\n 5\n 7\n 8\n 3\n 6\n 1\n 2\n\nParameters\n\nclique: clique\nalg: elimination algorithm\n\nReferences\n\nLiu, Joseph WH. \"Equivalent sparse matrix reordering by elimination tree rotations.\" Siam Journal on Scientific and Statistical Computing 9.3 (1988): 424-444.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Compression","page":"Library Reference","title":"CliqueTrees.Compression","text":"Compression{A} <: EliminationAlgorithm\n\nCompression(alg::EliminationAlgorithm; tao = 1.0)\n\nPreprocess a graph by identifying indistinguishable vertices. The algorithm alg is run on the compressed graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg = Compression(; tao=0.9)\n\njulia> treewidth(graph; alg)\n2\n\nParameters\n\nalg: elimination algorithm\ntao: threshold parameter for graph compression\n\nReferences\n\nAshcraft, Cleve. \"Compressed graphs and the minimum degree algorithm.\" SIAM Journal on Scientific Computing 16.6 (1995): 1404-1411.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SafeRules","page":"Library Reference","title":"CliqueTrees.SafeRules","text":"SafeRules{A, L, U} <: EliminationAlgorithm\n\nSafeRules(alg::EliminationAlgorithm, lb::WidthOrAlgorithm)\n\nSafeRules()\n\nPreprocess a graph using safe reduction rules. The algorithm lb is used to compute a lower bound to the treewidth; better lower bounds allow the algorithm to perform more reductions.\n\njulia> using CliqueTrees, TreeWidthSolver\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> alg1 = BT()\nBT\n\njulia> alg2 = SafeRules(BT(), MMW(), MF())\nSafeRules{BT, MMW{3}, MF}:\n    BT\n    MMW{3}\n    MF\n    tao: 1.0\n\njulia> @time treewidth(graph; alg=alg1) # slow\n  0.000163 seconds (1.37 k allocations: 88.094 KiB)\n2\n\njulia> @time treewidth(graph; alg=alg2) # fast\n  0.000043 seconds (100 allocations: 7.250 KiB)\n2\n\nParameters\n\nalg: elimination algorithm\nlb: lower bound algorithm (used to lower bound the treiwidth)\nub: elimination algorithm (used to upper bound the treewidth)\ntao: threshold parameter for graph compression\n\nReferences\n\nBodlaender, Hans L., et al. \"Pre-processing for triangulation of probabilistic networks.\" (2001).\nBodlaender, Hans L., Arie M.C.A. Koster, and Frank van den Eijkhof. \"Preprocessing rules for triangulation of probabilistic networks.\" Computational Intelligence 21.3 (2005): 286-305.\nvan den Eijkhof, Frank, Hans L. Bodlaender, and Arie M.C.A. Koster. \"Safe reduction rules for weighted treewidth.\" Algorithmica 47 (2007): 139-158. \n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.SafeSeparators","page":"Library Reference","title":"CliqueTrees.SafeSeparators","text":"SafeSeparators{A, M} <: EliminationAlgorithm\n\nSafeSeparators(alg::EliminationAlgorithm, min::PermutationOrAlgorithm)\n\nApple an elimination algorithm to the atoms of an almost-clique separator decomposition. The algorithm min is used to compute the decomposition.\n\nwarning: Warning\nThe algorithm min must compute a minimimal ordering. This property is guaranteed by the following algorithms:MCSM\nLexM\nMinimalChordal\n\nParameters\n\nalg: elimination algorithm\nmin: minimal elimination algorithm\n\nReferences\n\nBodlaender, Hans L., and Arie MCA Koster. \"Safe separators for treewidth.\" Discrete Mathematics 306.3 (2006): 337-350.\nTamaki, Hisao. \"A heuristic for listing almost-clique minimal separators of a graph.\" arXiv preprint arXiv:2108.07551 (2021).\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.ConnectedComponents","page":"Library Reference","title":"CliqueTrees.ConnectedComponents","text":"ConnectedComponents{A} <: EliminationAlgorithm\n\nConnectedComponents(alg::PermutationOrAlgorithm)\n\nConnectedComponents()\n\nApply an elimination algorithm to each connected component of a graph.\n\nParameters\n\nalg: elimination algorithm\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.permutation","page":"Library Reference","title":"CliqueTrees.permutation","text":"permutation([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nConstruct a fill-reducing permutation of the vertices of a simple graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> order, index = permutation(graph);\n\njulia> order\n8-element Vector{Int64}:\n 4\n 1\n 2\n 8\n 5\n 3\n 6\n 7\n\njulia> index == invperm(order)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.SupernodeType","page":"Library Reference","title":"CliqueTrees.SupernodeType","text":"SupernodeType\n\nA type of supernode partition. The options are\n\ntype name\nNodal nodal supernode partition\nMaximal maximal supernode partition\nFundamental fundamental supernode partition\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.DEFAULT_SUPERNODE_TYPE","page":"Library Reference","title":"CliqueTrees.DEFAULT_SUPERNODE_TYPE","text":"DEFAULT_SUPERNODE_TYPE = Maximal()\n\nThe default supernode partition.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CliqueTrees.Nodal","page":"Library Reference","title":"CliqueTrees.Nodal","text":"Nodal <: SupernodeType\n\nA nodal  supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Maximal","page":"Library Reference","title":"CliqueTrees.Maximal","text":"Maximal <: SupernodeType\n\nA maximal supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.Fundamental","page":"Library Reference","title":"CliqueTrees.Fundamental","text":"Fundamental <: SupernodeType\n\nA fundamental supernode partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.AbstractTree","page":"Library Reference","title":"CliqueTrees.AbstractTree","text":"AbstractTree{V} = Union{Tree{V}, SupernodeTree{V}, CliqueTree{V}}\n\nA rooted forest. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.rootindices","page":"Library Reference","title":"CliqueTrees.rootindices","text":"rootindices(tree::AbstractTree)\n\nGet the roots of a rooted forest.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.ancestorindices","page":"Library Reference","title":"CliqueTrees.ancestorindices","text":"ancestorindices(tree::AbstractTree, i::Integer)\n\nGet the proper ancestors of node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.Tree","page":"Library Reference","title":"CliqueTrees.Tree","text":"Tree{I, Prnt, Ptr, Tgt} <: AbstractUnitRange{I}\n\nA rooted forest T = (V, E) with edges oriented from leaf to root. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.eliminationtree","page":"Library Reference","title":"CliqueTrees.eliminationtree","text":"eliminationtree([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nConstruct a tree-depth decomposition of a simple graph.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = eliminationtree(graph);\n\njulia> tree\n8-element Tree{Int64, Vector{Int64}, Array{Int64, 0}, Vector{Int64}, Vector{Int64}}:\n 8\n └─ 7\n    ├─ 5\n    └─ 6\n       ├─ 1\n       ├─ 3\n       │  └─ 2\n       └─ 4\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.SupernodeTree","page":"Library Reference","title":"CliqueTrees.SupernodeTree","text":"SupernodeTree{V} <: AbstractVector{UnitRange{V}}\n\nA rooted forest T = (V, E) and a function snd: U → V. This type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.supernodetree","page":"Library Reference","title":"CliqueTrees.supernodetree","text":"supernodetree(graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE)\n\nConstruct a supernodal elimination tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.Clique","page":"Library Reference","title":"CliqueTrees.Clique","text":"Clique{V, E} <: AbstractVector{V}\n\nA clique of a clique tree.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CliqueTree","page":"Library Reference","title":"CliqueTrees.CliqueTree","text":"CliqueTree{V, E} <: AbstractVector{Clique{V, E}}\n\nA rooted forest T = (V, E) and functions\n\n   clique: V → 2ᵁ\nseparator: V → 2ᵁ\n\nThis type implements the indexed tree interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.cliquetree","page":"Library Reference","title":"CliqueTrees.cliquetree","text":"cliquetree([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE)\n\nConstruct a tree decomposition of a simple graph. The vertices of the graph are first ordered by a fill-reducing permutation computed by the algorithm alg. The size of the resulting decomposition is determined by the supernode partition snd.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = cliquetree(graph);\n\njulia> tree\n6-element CliqueTree{Int64, Int64}:\n [6, 7, 8]\n └─ [5, 7, 8]\n    ├─ [1, 5]\n    ├─ [3, 5, 7]\n    │  └─ [2, 3]\n    └─ [4, 5, 8]\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.treewidth","page":"Library Reference","title":"CliqueTrees.treewidth","text":"treewidth([weights, ]tree::CliqueTree)\n\nCompute the width of a clique tree.\n\njulia> using CliqueTrees\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = cliquetree(graph);\n\njulia> treewidth(tree)\n2\n\n\n\n\n\ntreewidth([weights, ]graph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM)\n\nCompute the width induced by an elimination algorithm.\n\njulia> using CliqueTrees, TreeWidthSolver\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> treewidth(graph; alg=MCS())\n3\n\njulia> treewidth(graph; alg=BT()) # exact treewidth\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.separator","page":"Library Reference","title":"CliqueTrees.separator","text":"separator(clique::Clique)\n\nGet the separator of a clique.\n\n\n\n\n\nseparator(tree::CliqueTree, i::Integer)\n\nGet the separator at node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.residual","page":"Library Reference","title":"CliqueTrees.residual","text":"residual(clique::Clique)\n\nGet the residual of a clique.\n\n\n\n\n\nresidual(tree::CliqueTree, i::Integer)\n\nGet the residual at node i.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.FilledGraph","page":"Library Reference","title":"CliqueTrees.FilledGraph","text":"FilledGraph{V, E} <: AbstractGraph{V}\n\nA filled graph.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.ischordal","page":"Library Reference","title":"CliqueTrees.ischordal","text":"ischordal(graph)\n\nDetermine whether a simple graph is chordal.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.isperfect","page":"Library Reference","title":"CliqueTrees.isperfect","text":"isperfect(graph, order::AbstractVector[, index::AbstractVector])\n\nDetermine whether an fill-reducing permutation is perfect.\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.SymbFact","page":"Library Reference","title":"CliqueTrees.SymbFact","text":"SymbFact{I}\n\nA symbolic factorization object.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CholFact","page":"Library Reference","title":"CliqueTrees.CholFact","text":"CholFact{T, I} <: Factorization{T}\n\nA Cholesky factorization object.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LDLTFact","page":"Library Reference","title":"CliqueTrees.LDLTFact","text":"LDLTFact{T, I} <: Factorization{T}\n\nAn LDLt factorization object.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.CholWork","page":"Library Reference","title":"CliqueTrees.CholWork","text":"CholWork{T, I}\n\nA workspace for the function cholesky!.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LDLTWork","page":"Library Reference","title":"CliqueTrees.LDLTWork","text":"LDLTWork{T, I}\n\nA workspace for the function ldlt!.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.LinWork","page":"Library Reference","title":"CliqueTrees.LinWork","text":"LinWork{T, I}\n\nA workspace for the function linsolve!.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliqueTrees.symbolic","page":"Library Reference","title":"CliqueTrees.symbolic","text":"symbolic(matrix::AbstractMatrix;\n    alg::EliminationAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE,\n)\n\nCompute a symbolic factorization of a sparse symmetric matrix. See the function cliquetree for more information about the parameters alg and snd.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> symbfact = CliqueTrees.symbolic(matrix)\nSymbFact{Int64}:\n    nnz: 19\n\nParameters\n\nalg: elimination algorithm\nsnd: supernode type\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.cholesky","page":"Library Reference","title":"CliqueTrees.cholesky","text":"cholesky(matrix::AbstractMatrix;\n    alg::EliminationAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE,\n)\n\nCompute the Cholesky factorization of a sparse positive definite matrix. The factorization occurs in two phases: symbolic and numeric. During the symbolic phase, a tree decomposition is constructed which will control the numeric phase. The speed of the numeric phase is dependant on the quality of this tree decomposition.\n\nThe symbolic phase is controlled by the parameters alg and snd. See the function cliquetree for more information.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> cholfact = CliqueTrees.cholesky(matrix)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\nParameters\n\nmatrix: sparse positive-definite matrix\nalg: elimination algorithm\nsnd: supernode type\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.cholesky!","page":"Library Reference","title":"CliqueTrees.cholesky!","text":"cholesky!(cholfact::CholFact, cholwork::CholWork, matrix::AbstractMatrix)\n\nCompute the Cholesky factorization of a sparse positive definite matrix using a pre-allocated workspace. See cholesky.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> symbfact = CliqueTrees.symbolic(matrix)\nSymbFact{Int64}:\n    nnz: 19\n\njulia> cholfact, cholwork = CliqueTrees.cholinit(matrix, symbfact);\n\njulia> CliqueTrees.cholesky!(cholfact, cholwork, matrix, symbfact)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\nParameters\n\ncholfact: Cholesky factor\ncholwork: workspace\nmatrix: sparse positive-definite matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.ldlt","page":"Library Reference","title":"CliqueTrees.ldlt","text":"ldlt(matrix::AbstractMatrix;\n    alg::EliminationAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE,\n)\n\nCompute the LDLt factorization of a sparse quasi definite matrix. The factorization occurs in two phases: symbolic and numeric. During the symbolic phase, a tree decomposition is constructed which will control the numeric phase. The speed of the numeric phase is dependant on the quality of this tree decomposition.\n\nThe symbolic phase is controlled by the parameters alg and snd. See the function cliquetree for more information.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> ldltfact = CliqueTrees.ldlt(matrix)\nLDLTFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\nParameters\n\nmatrix: sparse quasi-definite matrix\nalg: elimination algorithm\nsnd: supernode type\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.ldlt!","page":"Library Reference","title":"CliqueTrees.ldlt!","text":"ldlt!(ldltfact::LDLTFact, ldltwork::LDLTWork, matrix::AbstractMatrix)\n\nCompute the LDLT factorization of a sparse quasi definite matrix using a pre-allocated workspace. See ldlt.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> symbfact = CliqueTrees.symbolic(matrix)\nSymbFact{Int64}:\n    nnz: 19\n\njulia> ldltfact, ldltwork = CliqueTrees.ldltinit(matrix, symbfact);\n\njulia> CliqueTrees.ldlt!(ldltfact, ldltwork, matrix, symbfact)\nLDLTFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\nParameters\n\nldltfact: LDLT factor\nldltwork: workspace\nmatrix: sparse quasi-definite matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.linsolve!","page":"Library Reference","title":"CliqueTrees.linsolve!","text":"linsolve!(rhs::AbstractArray, cholfact::CholFact, side::Val)\n\nSolve a linear system of equations.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> rhs = rand(8, 2);\n\njulia> cholfact = CliqueTrees.cholesky(matrix)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> sol = CliqueTrees.linsolve!(rhs, cholfact, Val(false)) # sol = inv(matrix) * rhs\n8×2 Matrix{Float64}:\n  0.339907    0.0202252\n -0.364903    0.573497\n -0.243223    0.354763\n  0.293368   -0.00477056\n -0.336252    0.507332\n  0.600361   -0.655479\n  0.452218   -0.266566\n -0.0620433   0.0528108\n\nParameters\n\nrhs: right-hand side\ncholfact: factorized coefficient matrix\nside: left or right division\nVal(false): left division\nVal(true): right division\n\n\n\n\n\nlinsolve!(rhs::AbstractArray, linwork::LinWork{T}, cholfact::CholFact, side::Val)\n\nSolve a linear system of equations using a pre-allocated workspace.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> rhs = rand(8, 2);\n\njulia> cholfact = CliqueTrees.cholesky(matrix)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> linwork = CliqueTrees.lininit(2, cholfact)\nLinWork{Float64}:\n\njulia> sol = CliqueTrees.linsolve!(rhs, linwork, cholfact, Val(false)) # sol = inv(matrix) * rhs\n8×2 Matrix{Float64}:\n  0.339907    0.0202252\n -0.364903    0.573497\n -0.243223    0.354763\n  0.293368   -0.00477056\n -0.336252    0.507332\n  0.600361   -0.655479\n  0.452218   -0.266566\n -0.0620433   0.0528108\n\nParameters\n\nrhs: right-hand side\nlinwork: linear solve workspace\ncholfact: factorized coefficient matrix\nside: left or right division\nVal(false): left division\nVal(true): right division\n\n\n\n\n\nlinsolve!(rhs::AbstractArray, ldltfact::LDLTFact, side::Val)\n\nSolve a linear system of equations.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> rhs = rand(8, 2);\n\njulia> ldltfact = CliqueTrees.ldlt(matrix)\nLDLTFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> sol = CliqueTrees.linsolve!(rhs, ldltfact, Val(false)) # sol = inv(matrix) * rhs\n8×2 Matrix{Float64}:\n  0.339907    0.0202252\n -0.364903    0.573497\n -0.243223    0.354763\n  0.293368   -0.00477056\n -0.336252    0.507332\n  0.600361   -0.655479\n  0.452218   -0.266566\n -0.0620433   0.0528108\n\nParameters\n\nrhs: right-hand side\nldltfact: factorized coefficient matrix\nside: left or right division\nVal(false): left division\nVal(true): right division\n\n\n\n\n\nlinsolve!(rhs::AbstractArray, linwork::LinWork{T}, ldltfact::LDLTFact, side::Val)\n\nSolve a linear system of equations using a pre-allocated workspace.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> rhs = rand(8, 2);\n\njulia> ldltfact = CliqueTrees.ldlt(matrix)\nLDLTFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> linwork = CliqueTrees.lininit(2, ldltfact)\nLinWork{Float64}:\n\njulia> sol = CliqueTrees.linsolve!(rhs, linwork, ldltfact, Val(false)) # sol = inv(matrix) * rhs\n8×2 Matrix{Float64}:\n  0.339907    0.0202252\n -0.364903    0.573497\n -0.243223    0.354763\n  0.293368   -0.00477056\n -0.336252    0.507332\n  0.600361   -0.655479\n  0.452218   -0.266566\n -0.0620433   0.0528108\n\nParameters\n\nrhs: right-hand side\nlinwork: linear solve workspace\nldltfact: factorized coefficient matrix\nside: left or right division\nVal(false): left division\nVal(true): right division\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.cholinit","page":"Library Reference","title":"CliqueTrees.cholinit","text":"cholinit([T::Type, ]matrix::AbstractMatrix, symbfact::SymbFact)\n\nInitialize a cholesky factor and a factorization workspace.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> symbfact = CliqueTrees.symbolic(matrix)\nSymbFact{Int64}:\n    nnz: 19\n\njulia> cholfact, cholwork = CliqueTrees.cholinit(matrix, symbfact);\n\nParameters\n\nT: element type (optional)\nmatrix: sparse positive definite matrix\nsymbfact: symbolic factorization\n\n\n\n\n\n","category":"function"},{"location":"api/#CliqueTrees.lininit","page":"Library Reference","title":"CliqueTrees.lininit","text":"lininit(nrhs::Integer, cholfact::CholFact)\n\nInitialize a linear solve workspace.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> cholfact = CliqueTrees.cholesky(matrix)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> linwork = CliqueTrees.lininit(2, cholfact)\nLinWork{Float64}:\n\nParamerers\n\nnrhs: number of right-hand sides\ncholfact: factorized coefficient matrix\n\n\n\n\n\nlininit(nrhs::Integer, ldltfact::LDLTFact)\n\nInitialize a linear solve workspace.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> ldltfact = CliqueTrees.ldlt(matrix)\nLDLTFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\njulia> linwork = CliqueTrees.lininit(2, ldltfact)\nLinWork{Float64}:\n\nParamerers\n\nnrhs: number of right-hand sides\nldltfact: factorized coefficient matrix\n\n\n\n\n\n","category":"function"},{"location":"#CliqueTrees.jl","page":"CliqueTrees.jl","title":"CliqueTrees.jl","text":"CliqueTrees.jl implements clique trees in Julia. You can use it to construct tree decompositions and chordal completions of graphs.","category":"section"},{"location":"#Getting-Help","page":"CliqueTrees.jl","title":"Getting Help","text":"If you have a question about the library, feel free to open an issue or leave a message in the cliquetrees.jl Zulip channel.","category":"section"},{"location":"#Projects-using-CliqueTrees","page":"CliqueTrees.jl","title":"Projects using CliqueTrees","text":"BandedMatrices.jl\nBayesNets.jl\nCausalInference.jl\nEinExprs.jl\nIncrementalInference.jl\nOMEinsumContractionOrders.jl\nScruff.jl\nSparseMatrixColorings.jl\nSumOfSquares.jl\nTSSOS.jl","category":"section"},{"location":"#Installation","page":"CliqueTrees.jl","title":"Installation","text":"To install CliqueTrees.jl, enter the Pkg REPL by typing ] and run the following command.\n\npkg> add CliqueTrees","category":"section"},{"location":"#Basic-Usage","page":"CliqueTrees.jl","title":"Basic Usage","text":"","category":"section"},{"location":"#Tree-Decompositions","page":"CliqueTrees.jl","title":"Tree Decompositions","text":"The function cliquetree computes tree decompositions.\n\njulia> using CliqueTrees, LinearAlgebra, SparseArrays\n\njulia> graph = [\n           0 1 0 0 0 0 0 0\n           1 0 1 0 0 1 0 0\n           0 1 0 1 0 1 1 1\n           0 0 1 0 0 0 0 0\n           0 0 0 0 0 1 1 0\n           0 1 1 0 1 0 0 0\n           0 0 1 0 1 0 0 1\n           0 0 1 0 0 0 1 0\n       ];\n\njulia> label, tree = cliquetree(graph);\n\njulia> tree\n6-element CliqueTree{Int64, Int64}:\n [6, 7, 8]\n └─ [5, 7, 8]\n    ├─ [1, 5]\n    ├─ [3, 5, 7]\n    │  └─ [2, 3]\n    └─ [4, 5, 8]\n\nThe clique tree tree is a tree decomposition of the permuted graph graph[label, label]. A clique tree is a vector of cliques, so you can retrieve the clique at node 4 by typing tree[4].\n\njulia> tree[4]\n3-element Clique{Int64, Int64}:\n 4\n 5\n 8\n\nwarning: Warning\nThe numbers in each clique are vertices of the permuted graph graph[label, label]. You can see the vertices of the original graph by typingjulia> label[tree[4]]\n3-element Vector{Int64}:\n8\n3\n7Notice that the clique is no longer sorted.\n\nThe width of a clique tree is computed by the function treewidth.\n\njulia> treewidth(tree)\n2","category":"section"},{"location":"#Chordal-Completions","page":"CliqueTrees.jl","title":"Chordal Completions","text":"Clique trees can be used to construct chordal completions.\n\njulia> filledgraph = FilledGraph(tree)\n{8, 11} FilledGraph{Int64, Int64}\n\njulia> sparse(filledgraph)\n8×8 SparseMatrixCSC{Bool, Int64} with 11 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  1  1  ⋅\n\nThe graph filledgraph is ordered: its edges are directed from lower to higher vertices. The underlying undirected graph is a chordal completion of the permuted graph graph[label, label].\n\njulia> chordalgraph = Symmetric(sparse(filledgraph), :L)\n8×8 Symmetric{Bool, SparseMatrixCSC{Bool, Int64}}:\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  1  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  1\n 1  ⋅  1  1  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  1  ⋅  1  1  ⋅  1\n ⋅  ⋅  ⋅  1  1  1  1  ⋅\n\njulia> ischordal(graph)\nfalse\n\njulia> ischordal(chordalgraph)\ntrue\n\njulia> all(graph[label, label] .<= chordalgraph)\ntrue","category":"section"},{"location":"#Cholesky-Factorization","page":"CliqueTrees.jl","title":"Cholesky Factorization","text":"The function cholesky computes Cholesky factorizations of sparse positive-definite matrices.\n\njulia> import CliqueTrees\n\njulia> matrix = [\n           3 1 0 0 0 0 0 0\n           1 3 1 0 0 2 0 0\n           0 1 3 1 0 1 2 1\n           0 0 1 3 0 0 0 0\n           0 0 0 0 3 1 1 0\n           0 2 1 0 1 3 0 0\n           0 0 2 0 1 0 3 1\n           0 0 1 0 0 0 1 3\n       ];\n\njulia> cholfact = CliqueTrees.cholesky(matrix)\nCholFact{Float64, Int64}:\n    nnz: 19\n    success: true\n\nYou can solve linear systems of equations with the operators / and \\.\n\njulia> rhs = rand(8, 2);\n\njulia> sol = cholfact \\ rhs # sol = inv(matrix) * rhs\n8×2 Matrix{Float64}:\n -0.202009   -0.164852\n  0.661177    0.665989\n  0.173183   -0.126911\n  0.110932    0.0915613\n  0.375653    0.187998\n -0.556495   -0.378656\n -0.0751984   0.0536805\n  0.0793129   0.127395","category":"section"},{"location":"#Graphs","page":"CliqueTrees.jl","title":"Graphs","text":"Users can input graphs as adjacency matrices. Additionally, CliqueTrees.jl supports the HasGraph type from Catlab.jl and the AbstractGraph type from Graphs.jl. Instances of the latter should implement the following subset of the abstract graph interface.\n\nis_directed\nne\nnv\noutneighbors\nvertices\n\nSelf-edges are always ignored.","category":"section"},{"location":"#Citation","page":"CliqueTrees.jl","title":"Citation","text":"If you use CliqueTrees.jl for a publication, please cite it as follows.\n\n@misc{cliquetrees2025samuelson,\n  author = {Samuelson, Richard and Fairbanks, James},\n  url = {https://github.com/AlgebraicJulia/CliqueTrees.jl},\n  title = {CliqueTrees.jl: A Julia library for computing tree decompositions and chordal completions of graphs},\n  year = {2025}\n}","category":"section"}]
}
